# Greedy Algorithm 
* > ## 정의
    욕심쟁이 알고리즘은 각 단계에서 지역적으로 최적인 선택을 하며 전역 최적해를 찾기 위한 헤비스틱 알고리즘이다.

* > ## 작동 방식 
    각 단계에서 욕심쟁이 알고리즘은 지금까지의 결과에 관계없이 지금 상황에서 가장 좋아보이는 선택을 한다.

* > ## 예제 
    욕심쟁이 알고리즘의 일반적인 예로는 짐적인 문제, 허프만 코딩 알고리즘, 그래프에서 최단 경로를 찾는 다익스트라 알고리즘 등이 있다.

* > ## 장단점 
    욕심쟁이 알고리즘의 장점 중 하나는 각 단계에서 제공되는 정보를 기반으로 선택을 하기 때문에 매우 효율적일 수 있다는 것이다. 그러나 욕심쟁이 알고리즘은 항상 전역 최적해를 찾을 수 있는 것은 아니고 자신의 선택에 대한 장기적인 결과를 고려하지 않을 수 있습니다.

* > ## 언제 사용할 것인가
     욕심쟁이 알고리즘은 지역적으로 최적인 선택이 전역 최적해로 이어지는 최적화 문제에 적합합니다. 그러므로 욕심쟁이 접근 방식이 적합한지 잘 판단해야 합니다.


<br><br>
* > 내일 배울 DP와 대립관계임
* > 그냥 코딩하다 순간순간 필요한 번쩍이는 알고리즘들이 다 Greedy임. 똑똑한 사람이 잘함. 
* > BFS 처럼 특정 알고리즘이 있는게 아니라, 매순간마다 그냥 최적의 선택을 하는거임. 





<br><br><br><br><br><br>
## 신입사원 (BOJ 1946) Greedy
* > 알고리즘은 잘 짰지만, 코드적으로 최적화해서 풀지 못함. 
* > 이중 for문 -> 단일 for문  ( 단일 변수 선언 + 계속해서 변수 쪽쪽 바꿔주기 )
```c++
    for(int i=0; i<K; i++){
            if(visited[i]==true){
                for(int j=i; j<K; j++){
                        if(items[i].second < items[j].second) { 
                            visited[j] = false; 
                        }    
                }
            }
        }
```
--> 
```c++
    int second = items[0].second ; 
        for (int i = 1; i < K ; i++) { 
            if ( second >= items[i].second ) { 
                cnt++; 
                second = items[i].second ; 
            }            
        }
```

## 16953 (A -> B)
( Binary 생성 후 BFS x)
1. 수열의 일반항 찾듯이 규칙 찾기. 끝. 

