# Bellman-Ford (벨만포드)
* > 음의 가중치를 다룰 수 있는 최단거리 구하기. 
* > -무한로프 잘 컨트롤 해줘야 함. 
* > 
## 벨만-포드 vs 다익스트라. 
다익스트라 : 매번 방문하지 않은 노드 중에서, 최단 거리가 가장 짧은 노드를 선택하여 한 단계씩 최단 거리를 구해나간다. 
* 시간복잡도가 빠르다. O(E logV)

벨만포드 : 매 단계마다 모든 간선을 전부 확인하면서, 노드간의 최단거리를 구한다. 
매 반복마다 모든 간선을 호가인함.
* 시간 복잡도가 느리다. O(VE)


## 벨만-포드 수행과정. 
1. 출발노드를 설정한다. 
2. 최단 거리 테이블을 초기화한다. 
3. (V-1)번 반복. 
    1. 모든 간선 E개를 하나씩 확인한다.
    2. 각 edge를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다. 
* > if( 음수 무한 순환 발생하는 지 체크하고 싶어? ) -> 3번과정을 한번더 수행하면됨. 즉 V 만큼 반복을 하는거지. (이때 최단 거리 테이블이 갱신된다면 음수 간선 순환이 존재하는 것임. )

![Example_1](https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2F8d933209-5062-4d00-8520-eb59ce465fd4%2Fimage.png)

![v-1](https://velog.velcdn.com/images%2Fqweadzs%2Fpost%2Fd093a7a3-4713-4f7f-9636-833c4148c684%2Fimage.png)
> 다음 그림과 같이 s에서 u까지의 최단 경로가 다음과 같다고 가정하겠습니다.

> 처음은 모두 최단 거리를 확정 하지 않았기 때문에 upper[]입니다.

> 시작 노드인 s는 upper[s] = dist[s] = 0을 보장합니다.

> 모든 간선을 탐색해 완화 과정을 실행합니다.

> 그럼 upper[a] <= upper[s] + w(s, a)가 성립하고 upper[s] = dist[s] = 0이기 때문에 upper[a] <= w(s, a)입니다.

> 그런데 w(s, a)는 s에서 a로 가는 최단 경로여야 합니다. 왜냐하면 최단 경로가 아니면 처음에 가정한 s에서 u까지의 최단 경로에 대한 모순이 생기기 때문입니다.

> 이것을 반복하면 모든 노드에 대한 최단 거리를 확정 시킬 수 있는데, 위 과정을 정확히 V-1번 반복하면 모든 노드를 확정시킬 수 있습니다.

> 왜냐하면, 최악의 경우일 때 최대 V개의 정점을 가지고, 그 때의 간선의 개수가 V-1기 때문입니다. 위 그림의 경우과 같습니다.






<br><br><br><br><br><br><br><br>
# Floyd-Warshall (플로이드-워셜)

* feat. 모든 최단 경로를 구하는 알고리즘. 
* 다익스트라 -> 하나의 정점에서 다른 정점까지의 최단거리를 구함. 
* 플로이드 -> 한번 실행으로 "모든 노드 간 최단 경로를 구할 수 있음"
* > 2차원 인접행렬을 구성. 
* > 라운드마다 각 경로에서 새로운 중간노드를 사용할 수 잇는 노드를 선택하고, 더 짧은 길이를 선택하여 줄이는 과정을 반복함.  ( 이게 중요 )

